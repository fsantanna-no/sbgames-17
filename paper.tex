% Sample document for SBGames papers
% Uses a slightly modified IEEE VGTC template in conference mode

\documentclass{vgtc}                          % final (conference style)

%% These three lines bring in essential packages: ``mathptmx'' for Type 1 
%% typefaces, ``graphicx'' for inclusion of EPS figures. and ``times''
%% for proper handling of the times font family.

\usepackage{mathptmx}
\usepackage{graphicx}
\usepackage{times}
\usepackage{xspace}
\usepackage{url}
\usepackage{verbatim}

\usepackage{listings}
\usepackage{color}
    \definecolor{light}{gray}{0.97}
    \definecolor{dark}{gray}{0.30}
\lstset{
%columns=fullflexible,
%basicstyle=\ttfamily,
escapeinside={||},
    %mathescape=true,
    language=C, % choose the language of the code
    basicstyle=\fontfamily{pcr}\selectfont\scriptsize\color{black},
    keywordstyle=\color{black}\bfseries, % style for keywords
    numbers=none, % where to put the line-numbers
    numberstyle=\tiny, % the size of the fonts that are used for the line-numbers
    backgroundcolor=\color{light},
    showspaces=false, % show spaces adding particular underscores
    showstringspaces=false, % underline spaces within strings
    showtabs=false, % show tabs within strings adding particular underscores
    %frame=single, % adds a frame around the code
    tabsize=2, % sets default tabsize to 2 spaces
    %rulesepcolor=\color{gray}
    captionpos=b, % sets the caption-position to bottom
    breaklines=false, % sets automatic line breaking
    %breakatwhitespace=false,
    numbersep=2em,
    % C was used in the blocksworld example to refer to block C and nowhere else
    emph={par,or,hor,do,end,loop,await,emit,input,event,call,with,%
          var,and,then,else,return,pure,deterministic,nohold,finalize,%
          class, every, FOREVER, this, spawn, in, pool, watching, until, 
          interface, each, abort, when, signal, PROC, CHAN, SIGNAL, PAR, not,
          bool, data, tag, escape, new, traverse,implementation,output,
          native,@const,@pure,@safe,define},
    emphstyle={\bfseries},
    commentstyle=\color{dark}\scriptsize,
    %xleftmargin=20pt,
    %xrightmargin=20pt,
    framesep=20pt,
    %upquote=true,
    %aboveskip={1.5\baselineskip},
}

\newcommand{\CEU}{\textsc{C\'{e}u}\xspace}
\newcommand{\code}[1] {{\small{\texttt{#1}}}}
\newcommand{\ax}{\code{[a]}\xspace}
\newcommand{\bx}{\code{[b]}\xspace}

%% We encourage the use of mathptmx for consistent usage of times font
%% throughout the proceedings. However, if you encounter conflicts
%% with other math-related packages, you may want to disable it.

%% If you are submitting a paper to a conference for review with a double
%% blind reviewing process, please replace the value ``0'' below with your
%% OnlineID. Otherwise, you may safely leave it at ``0''.
\onlineid{0}

%% declare the category of your paper, only shown in review mode
\vgtccategory{Research}

%% Paper title.

\title{Structured Synchronous Reactive Programming for Game Development
        \\ \Large{Case Study: On Rewriting Pingus from C++ to \CEU}}

\author{Francisco Sant'Anna
        \\ Departamento de Inform\'atica e Ci\^encia da Computa\c{c}\~ao, UERJ
        \\ francisco@ime.uerj.br}

\abstract{Abstract.

\smallskip

\noindent \textbf{Keywords:} Radiosity, global illumination, constant time.
}

%% Copyright space is enabled by default as required by guidelines.
%% It is disabled by the 'review' option or via the following command:
% \nocopyrightspace

\begin{document}

\firstsection{Introduction}

\maketitle

Pingus%
\footnote{Pingus: \url{http://pingus.seul.org/}}
is an open-source clone of Lemmings%
\footnote{Lemmings: \url{https://en.wikipedia.org/wiki/Lemmings_(video_game)}},
a puzzle-platformer video game.      
The objective of the game is to guide a group of penguins through a number of
obstacles towards a designated exit%
\footnote{Pingus gameplay: \url{https://www.youtube.com/watch?v=MKrJgIFtJX0}}.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{pingus}
\caption{Pingus gameplay.
\label{fig.sweeney}
}
\end{figure}

Pingus is developed in standard object-oriented C++, the \emph{lingua franca}
of game development \cite{games.patterns}.
The codebase is about 40.000 lines of code (LoCs)%
\footnote{Pingus repository: \url{https://github.com/Pingus/pingus/tree/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src}}, divided into
the engine, level editor, auxiliary libraries, and the game logic itself.

According to Tim Sweeney (of Unreal Engine fame), about half the complexity in
game development resides in \emph{simulation} (aka \emph{game logic}), but
which accounts for only 10\% of the CPU budget~\cite{games.sweeney}.
The game logic ``models the state of the game world as interacting objects
evolve over time''.
The high development costs contrasting with the low impact on performance
appeals for alternatives with productivity in mind, especially considering that
it is the game logic that varies the most between projects.
Sweeney states that ``will gladly sacrifice 10\% of our performance for 10\%
higher productivity''.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{sweeney}
\caption{Three kinds of code~\cite{games.sweeney}.
\label{fig.sweeney}
}
\end{figure}

Object-oriented games use the \emph{observer pattern}~\cite{games.patterns}
in the game logic to handle events from the environment (e.g., key presses and
timers) and also as a notification mechanism between game entities.
%
The observers are short-lived callbacks which must execute as fast as possible
and in real time to keep the game reactive to incoming events.
%
For this reason, callbacks cannot contain long-lasting locals and loops, which
are elementary capabilities of classical structured
programming~\cite{rp.deprecating,rp.rescala,sync_async.cooperative}.
%
In this sense, callbacks actually disrupt structured programming, becoming
``our generation's \code{goto}''.%
\footnote{``Callbacks as our Generations' Go To Statement'':
\url{http://tirania.org/blog/archive/2013/Aug-15.html}}%
\footnote{``Escape from Callback Hell'':
\url{http://elm-lang.org/learn/Escape-from-Callback-Hell.elm}}

\CEU~\cite{ceu.sensys13,ceu.mod15} is a programming language that aims to offer
a concurrent and expressive alternative to C/C++ with the characteristics that
follow:
%
\begin{itemize}
\item \emph{Reactive}: code only executes in reactions to events.
\item \emph{Structured}: programs use structured control mechanisms, such as
      \code{await} (to suspend a line of execution), and \code{par} (to combine
      multiple lines of execution).
\item \emph{Synchronous}: reactions run atomically and to completion on each
      line of execution, i.e., there's no implicit preemption or real
      parallelism.
\end{itemize}
%
Structured reactive programming eliminates callbacks, letting programmers write
code in direct and sequential style and recover from the inversion of control
imposed by the observer pattern~\cite{rp.deprecating}.
%
\CEU supports logical parallelism with a resource-efficient implementation in
terms of memory and CPU usage~\cite{ceu.sensys13}.
The runtime is single threaded and the language requires no garbage
collection.

Contributions:
    - patterns
    - solutions

\section{Control-Flow Patterns}

The rewriting process consisted of identifying sets of callbacks implementing
*control-flow behaviors* in the game and translating them to \CEU using
appropriate structured constructs.
As an example, a double mouse click is characterized by a first click, followed
by a maximum amount of time, followed by a second click.
This behavior depends on different events (clicks and timers) which have to
occur in a particular order.
In C++, the implementation involves callbacks crossing reactions to successive
events which manipulate state variables explicitly.

We can identify control-flow behaviors in C++ by looking for class members with
identifiers resembling verbs, statuses, and counters (e.g.,
\code{pressed},
\code{particle\_thrown},
\code{mode}, and
\code{delay\_count}).
Good chances are that variables with these ``suspicious names'' encode some
form of control-flow progression that cross multiple callback invocations.

We selected 9 representative game behaviors and describe their
implementations in C++ and \CEU.
We also categorized these examples in 5 abstract C++ control-flow patterns that
likely apply to other games:

\begin{enumerate}
\item \emph{Finite State Machines}:
    State machines describe the behavior of entities by mapping event
    occurrences to transitions between states that trigger appropriate actions.
\item \emph{Continuation Passing}:
    The completion of a long-lasting activity may carry a continuation, i.e.,
    some action to execute next.
\item \emph{Dispatching Hierarchies}:
    Entities typically form a dispatching hierarchy in which a container that
    receives a stimulus automatically forwards it to its managed children.
\item \emph{Lifespan Hierarchies}:
    Entities typically form a lifespan hierarchy in which a terminating
    container entity automatically destroys its managed children.
\item \emph{Signaling Mechanisms}:
    Entities often need to communicate explicitly through signaling mechanisms,
    especially if there is no hierarchy relationship between them.
\end{enumerate}

\subsection{Finite State Machines \\ Case Study: The Armageddon Button Double Click}
%\label{sec.patterns.fsm}

State machines describe the behavior of entities by mapping event occurrences
to transitions between states that trigger appropriate actions.

%\subsection{The Armageddon Button Double Click}
%\label{sec.patterns.fsm.armageddon}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{double-click-opt}
\caption{Double click detection.
\label{fig.armageddon}
}
\end{figure}

In Pingus, a double click in the \emph{Armageddon} button at the bottom right
of the screen literally explodes all pingus (Figure~\ref{fig.armageddon}).
Figure~\ref{fig.armageddon.code} compares the implementations in C++ and \CEU.

\begin{figure*}
\begin{minipage}[t]{0.55\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
ArmageddonButton::ArmageddonButton(<...>):
    RectComponent(<...>),
    pressed(false); // button initially not pressed
    press_time(0);    // how long since 1st click?
    <...>
{
    <...>
}

void ArmageddonButton::draw (<...>) {
    <...>
}

void ArmageddonButton::update (float delta) {
    <...>
    if (pressed) {
        press_time += delta;
        if (press_time > 1.0f) {
            pressed = false; // give up, 1st click
            press_time = 0;  // was too long ago
        }
    } else {
        <...>
        press_time = 0;
    }
}

void ArmageddonButton::on_click (<...>) {
    if (pressed) {
        server->send_armageddon_event();
    } else {
        pressed = true;
    }
}
\end{lstlisting}
\centering\small{\ax Implementation in C++}
\end{minipage}
%
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
do
    var& RectComponent c = <...>;
    <...>
    loop do
        await c.component.on_click;
        watching 1s do
            await c.component.on_click;
            break;
        end
    end
    <...>
    emit outer.game.go_armageddon;
end




















.
\end{lstlisting}
\centering\small{\bx Implementation in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Shared-memory concurrency in \CEU:
example \ax is safe because the trails access \code{x} atomically in different 
reactions;
example \bx is unsafe because both trails access \code{y} in the same reaction.
\label{lst.shared}
}
\end{figure*}

In C++, the class \code{ArmageddonButton} implements methods for rendering the
button and handling mouse and timer events.
The listing focus on the double click detection, hiding unrelated parts with
\code{<...>}.
%
The methods \code{update} (ln. 14--26) and \code{on\_click} (ln. 28--34) are
examples of \emph{short-lived callbacks}, which are pieces of code that execute
atomically in reaction to external input events.
The callback \code{on\_click} reacts to mouse clicks detected by the button
base class \code{RectComponent} (ln. 2), while the callback \code{update}
continuously reacts to the passage of time, frame by frame.
Callbacks are short lived because they must react to input as fast as possible
to let other callbacks execute, keeping the game with real-time responsiveness.
%
The class first initializes the variable \code{pressed} to track the first
click (ln. 3,32).
It also initializes the variable \code{press\_time} to count the time since the
first click (ln. 4, 17).
If another click occurs within 1 second, the class signals the double click to
the application (ln. 30).
Otherwise, the \code{pressed} and \code{press\_time} state variables are reset
(ln. 19--20). 
%
Figure~\ref{fig.armageddon.fsm} illustrates how we can model the double-click 
behavior in C++ as a state machine.
The circles represent the state of the variables in the class, while the arrows 
represent the callbacks manipulating state.
%
Note in the code how the accesses to the state variables are spread
across the entire class.
For instance, the distance between the initialization of \code{pressed} (ln.
3) and the last access to it (ln. 32) is over 40 lines in the original file.
Arguably, this dispersion of code across methods makes the understanding and 
maintenance of the double-click behavior more difficult.
Also, even though the state variables are private, unrelated methods such as 
\code{draw}`, which is defined in middle of the class (ln. 10--12), can
potentially access them.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{double-click}
\caption{State machine for the \emph{Armageddon} double click.
\label{fig.armageddon.fsm}
}
\end{figure}

\CEU provides structured constructs to deal with events, aiming to eradicate
explicit manipulation of state variables for control-flow purposes.
%
The loop detection (ln. 4--10) awaits the first click (ln. 5) and then, while
watching 1 second (ln. 6--9), awaits the second click (ln. 7).
If the second click occurs within 1 second, the \code{break} terminates the
loop (ln. 8) and the \code{emit} signals the double click to the application
(ln. 12).
Otherwise, the \code{watching} block as a whole aborts and restarts the loop, 
falling back to the first click \code{await} (ln. 5).
%
Double click detection in \CEU doesn't require state variables and is entirely
self-contained in the \code{loop} body (ln. 4--10).
Furthermore, these 7 lines of code \emph{only} detect the double click, leaving
the actual effect to happen outside the loop (ln. 12).

\subsection{Continuation Passing \\ Case Study: Advancing Pages in the Story Screen}

The completion of a long-lasting activity may carry a continuation, i.e., some
action to execute next.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{story-anim}
\caption{The Story screen.
\label{fig.story}
}
\end{figure}

The clickable \emph{blue dots} in the campaign world map transit to ambience
story screens (Figure~\ref{fig.story}).
A story is composed of multiple pages and, inside each page, the words of the
story appear incrementally over time.
A first click in the button \code{>>>} fast forwards the words to show the full 
page.
A second click advances to the next page, until the story terminates.
If the page completes before a click (due to the time elapsing), a first click 
advances to the next page.

\begin{figure*}
\begin{minipage}[t]{0.55\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
StoryScreenComponent::StoryScreenComponent (<...>) :
    <...>
{
    pages        = <...>; // vector with loaded pages
    current_page = pages.back(); // first loaded page
    displayed    = false; // if current is complete
    <...>
}

<...>   // draw page over time

void StoryScreenComponent::update (<...>) {
    <...>
    if (&lt;all-words-appearing&gt;) {
        displayed = true;
    }
}

void StoryScreenComponent::next_text() {
    if (!displayed) {
        displayed = true;
        <...>     // remove current page
    } else {
        pages.pop_back();
        if (!pages.empty()) { // next page
            current_page = pages.back();
            displayed    = false;
            <...>
        } else {
            <...> // terminates the story screen
        }
    }
}
\end{lstlisting}
\centering\small{\ax Implementation in C++}
\end{minipage}
%
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
code/await Story (void) -> bool do
    <...>
    event void next_text; // clicks in >>>

    { pages = <...>; } // same as in C++
    loop i in [0 <- {pages.size()}[ do
        par/or do
            watching next_text do
                <...> // advance text
            end
            await next_text;
        with
            <...> // redraw _pages[i]
        end
    end
end

















.
\end{lstlisting}
\centering\small{\bx Implementation in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Shared-memory concurrency in \CEU:
example \ax is safe because the trails access \code{x} atomically in different 
reactions;
example \bx is unsafe because both trails access \code{y} in the same reaction.
\label{lst.shared}
}
\end{figure*}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{story}
\caption{State machine for the Story screen.
\label{fig.story}
}
\end{figure}

In C++, the class \code{StoryScreenComponent} implements the method
\code{next\_text}, which is a callback for clicks in \code{>>>}.
%
The variable `pages` (ln. 4--5, 24--26) is a vector holding each page, but
which also encodes \emph{continuations} for the story progress:
each call to \code{next\_text} that advances the story (ln. 23--32) removes the 
current page (ln. 24) and sets the next action to perform (i.e., ``display a
new page'') in the variable \code{current\_page} (ln. 26).
Figure~\ref{fig.story} illustrates the continuation mechanism to advance 
pages and also a state machine for fast forwarding words (inside the dashed
rectangle).
The state variable \code{displayed} (ln. 6,15,20,21,27) switches between the
behaviors ``advancing text'' and ``advancing pages'', which are both handled
intermixed inside the method \code{next\_text}.

The code in \CEU uses the internal event \code{next\_text}, which is emitted
from clicks in \code{>>>}.
%
The sequential navigation from page to page uses a loop in direct style
(ln. 6--15) instead of explicit state variables for the continuation and state
machine.
While the text advances in an inner loop (hidden in ln. 9), we watch the
\code{next\_text} event that fast forwards it.
The loop may also eventually terminate with the time elapsing normally.
This way, we do not need a variable (such as `displayed` in C++) to switch 
between the states ``advancing text'' and ``advancing pages''.
The \code{par/or} makes the page advance logic to execute in parallel with the
redrawing code (ln. 13).
Whenever the page advances, the redrawing code is automatically aborted
(due to the \code{or} modifier).
The \code{await next\_text} in sequence (ln. 11) is the condition to advance to
the next page.
%
Note that, unlike the implementation in C++, the ``advancing text'' behavior is
not intermixed with the ``advancing pages'' behavior, instead, it is
encapsulated inside the inner loop nested with a deeper indentation (ln. 9).

\subsection{Dispatching Hierarchies \\ Case Study: Bomber `draw` and `update` callbacks}

Entities typically form a dispatching hierarchy in which a container that
receives a stimulus automatically forwards it to its managed children.

\begin{figure*}
\begin{minipage}[t]{0.50\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
class Bomber : public PinguAction {
    <...>
    Sprite sprite;
}

Bomber::Bomber (<...>) : <...> {
    sprite.load(<...>);
    <...>
}

void Bomber::update () {
    sprite.update ();
}

void Bomber::draw (SceneContext& gc) {
    <...>
    gc.color().draw(sprite, <...>);
}
\end{lstlisting}
\centering\small{\ax Implementation in C++}
\end{minipage}
%
\begin{minipage}[t]{0.50\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
code/await Bomber (void) -> ActionName do
    <...>
    var&? Sprite sprite = spawn Sprite(<...>);
    <...>
end
\end{lstlisting}
\centering\small{\bx Implementation in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Shared-memory concurrency in \CEU:
example \ax is safe because the trails access \code{x} atomically in different 
reactions;
example \bx is unsafe because both trails access \code{y} in the same reaction.
\label{lst.shared}
}
\end{figure*}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{story}
\caption{State machine for the Story screen.
\label{fig.story}
}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{hierarchy}
\caption{Dispatching chain for \code{update}.
\label{fig.hier}
}
\end{figure}

In C++, the class \code{Bomber} declares a \code{sprite} member to handle its
animation frames (Figure~\ref{fig.TODO}).
%
The \code{Sprite} class is part of the game engine and knows how to update and
render itself.
However, the \code{Bomber} still has to respond to \code{update} and
\code{draw} requests from the game and forward them to the sprite
(ln. 11--13 and 15--18).
%
To understand how the \code{update} callback flows from the original
environment stimulus from the game down to the sprite, we need to follow a long
chain of 7 method dispatches (Figure~\ref{fig.hier}):
%
\begin{enumerate}
\item \code{ScreenManager::display} in the main game loop calls \code{update}.
\item \code{ScreenManager::update} calls \code{last\_screen->update} for the
      active game screen (a \code{GameSession} instance, considering the
      \code{Bomber}).
\item \code{GameSession::update} calls \code{world->update}.
\item \code{World::update} calls \code{obj->update} for each object in the
      world.
\item \code{PinguHolder::update} calls \code{pingu->update} for each pingu
      alive.
\item \code{Pingu::update} calls \code{action->update} for the active pingu
      action.
\item \code{Bomber::update} calls \code{sprite.update}.
      \code{Sprite::update} finally updates the animation frame.
\end{enumerate}
%
Each dispatching step in the chain is necessary considering the game
architecture:
%
\begin{itemize}
\item With a single assignment to \code{last\_screen}, we can easily deactivate
      the current screen and redirect all dispatches to a new screen.
\item The \code{World} class manages and dispatches events to all game
      entities, such as all pingus and traps, with the common interface
      \code{WorldObj}.
\item Since it is common to iterate only over the pingus (vs. all world
      objects), the container \code{PinguHolder} manages all pingus.
\item Since a single pingu can change between actions during lifetime, the
      \code{action} member decouples them with another level of indirection.
\item Sprites are part of the game engine and are reusable everywhere (e.g., UI
      buttons, world objects, etc.), so it is also convenient to decouple them
      from actions.
\end{itemize}
%
The \code{draw} callback flows through the same dispatching hierarchy until
reaching the \code{Sprite} class.

In \CEU, the \code{Bomber} action spawns a \code{Sprite} animation instance on
its body.
%
The \code{Sprite} instance (ln. 3) can react directly to external \code{dt} and
\code{redraw} events (which are analogous to \code{update} and \code{redraw}
callbacks, respectively), bypassing the program hierarchy entirely.
While and \emph{only while} the bomber abstraction is alive, the sprite
animation is also alive.
The radical decoupling between the program hierarchy and reactions to events
eliminates dispatching chains entirely.

\subsection{Lifespan Hierarchies \\ Case Study: The Pingus Container}

Entities typically form a lifespan hierarchy in which a terminating
container entity automatically destroys its managed children.

\begin{figure*}
\begin{minipage}[t]{0.50\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
Pingu* PinguHolder::create_pingu (<...>) {
    <...>
    Pingu* pingu = new Pingu (<...>);
    pingus.push_back(pingu);
    <...>
}

void PinguHolder::update() {
    <...>
    while(pingu != pingus.end()) {
        (*pingu)->update();
        if ((*pingu)->get_status() == Pingu::PS_DEAD) {
            pingu = pingus.erase(pingu);
        }
        <...>
        ++pingu;
    }
}
\end{lstlisting}
\centering\small{\ax Implementation in C++}
\end{minipage}
%
\begin{minipage}[t]{0.40\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
code/await Game (void) do
    <...>
    pool[] Pingu pingus;
    code/await Pingu_Spawn (<...>) do
        <...>
        spawn Pingu(<...>) in outer.pingus;
    end
    <...>   // code invoking Pingu_Spawn
end

TODO

code/await Pingu (<...>) do
    <...>
    loop do
        await outer.game.dt;
        if call Pingu_Rel_Getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
            <...>
            escape {PS_DEAD};
        end
    end
end
\end{lstlisting}
\centering\small{\bx Implementation in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Shared-memory concurrency in \CEU:
example \ax is safe because the trails access \code{x} atomically in different 
reactions;
example \bx is unsafe because both trails access \code{y} in the same reaction.
\label{lst.shared}
}
\end{figure*}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{story}
\caption{State machine for the Story screen.
\label{fig.story}
}
\end{figure}

In C++, the class \code{PinguHolder} is a container that holds all pingus
alive.
%
The method \code{PinguHolder::create\_pingu} (ln. 1--6) is called periodically
to create a new \code{Pingu} and add it to the \code{pingus} collection
(ln. 3--4).
The method \code{PinguHolder::update} (ln. 8--18) checks the state of all
pingus on every frame, removing those with the dead status (ln. 12--14).
%
Entities with dynamic lifespan in C++ require explicit \code{add} and
\code{remove} calls associated to a container (ln. 4,13).
Without the \code{erase} call above, a dead pingu would remain in the
collection with updates on every frame (ln. 11).
Since the \code{redraw} behavior for a dead pingu is innocuous, the death could
go unnoticed but the program would keep consuming memory and CPU time.
This problem is known as the \emph{lapsed listener}~\cite{TODO} and also occurs
in languages with garbage collection:
A container typically holds a strong reference to a child (sometimes the only 
reference to it), and the runtime cannot magically detect it as garbage.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{pool}
\caption{Lifespan of dynamic instances.
\label{fig.pool}
}
\end{figure}

\CEU supports \code{pool} declarations to hold dynamic abstraction instances.
Additionally, the \code{spawn} statement supports a pool identifier to
associate the new instance with a pool.
%
The game screen spawns a new \code{Pingu} on every invocation of
\code{Pingu\_Spawn}.
%
The \code{spawn} statement (ln. 6) specifies the pool declared at the top-level
block of the game screen (ln. 3).
In this case, the lifespan of the new instances follows the scope of the pool
(ln. 1--9) instead of the enclosing scope of the \code{spawn} statement
(ln. 4--7).
Since pools are also subject to lexical scope, the lifespan of all dynamically
allocated pingus is constrained to the game screen.
%
Lexical scopes handle memory and event dispatching automatically for static
instances and also for pools.
However, the lifespan of a dynamic instance does not necessarily have to match
the lifespan of its associated pool (Figure~\ref{fig.pool}).
In \CEU, when the execution block of a dynamic instance terminates, which
characterizes its *natural termination*, the instance is automatically removed
from its pool.
Therefore, dynamic instances do not require any extra bookkeeping related to 
containers or explicit deallocation.
%
To remove a pingu from the game in \CEU, we just need to terminate its execution
block according to the appropriate conditions:
%
The \code{escape} statement (ln. TODO) aborts the execution block of the
\code{Pingu} instance, removing it from its associated pool automatically.
Hence, a dynamic instance that terminates naturally leaves no traces in the 
program.

\subsection{Signaling Mechanisms\\ Case Study: Global Keys and the Options Menu}

Entities often need to communicate explicitly through signaling mechanisms,
especially if there is no hierarchy relationship between them.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{options-anim-opt}
\caption{The \emph{Mouse Grab} configuration option.
\label{fig.options}
}
\end{figure}

The *Mouse Grab* option restricts the mouse movement to the game window
boundaries (Figure~\ref{fig.options}).
The option can be set anywhere in the game by pressing *Ctrl-G*.
In addition, the *Options* menu has a check box to toggle the *Mouse Grab*
option with mouse clicks while still responding to *Ctrl-G* presses.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{options-anim-opt}
\caption{Mutual dependency between signals.
\label{fig.events}
}
\end{figure}

The implementations in C++ and \CEU use a signalling mechanism to connect the
key presses, the check box, and a configuration manager that applies the
appropriate side effects in the game (i.e., restrict the mouse movement).
Figure~\ref{fig.events} illustrates how the mutual notifications create a 
dependency cycle between the configuration manager and the check box.

\begin{figure*}
\begin{minipage}[t]{0.50\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
void GlobalEvent::on_button_press (<...>) {
    <...>
    switch (event.keysym.sym) {
        case SDLK_g:
            if (keystate[SDLK_LCTRL] || keystate[SDLK_RCTRL]) {
                config_manager.set_mouse_grab(          @ctrl_g_cpp
                    !config_manager.get_mouse_grab());
            }
            break;
        <...>
    }
}

///

boost::signals2::signal<void(bool)> on_mouse_grab_change;   // definition in `config_manager.h` @signal_def

void ConfigManager::set_mouse_grab (bool v) {   @set_mouse_grab
    <...>
    if (v != get_mouse_grab()) {                @if_1
        <...>   // the actual "grab" effect
        on_mouse_grab_change(v);                @signal
    }                                           @if_2
}

///

boost::signals2::signal<void (bool)> on_change;   // definition in `check_box.hpp`

void CheckBox::set_state (bool is_on, bool send_signal) {   @last_argument
    <...>   // switches the check box state
    if (send_signal) {      @if_cb_1
        on_change(is_on);
    }                       @if_cb_2
}

///

typedef std::vector&lt;boost::signals2::connection&gt; Connections;   // definition in `option_menu.hpp`
Connections connections;                                        // definition in `option_menu.hpp`

OptionMenu::OptionMenu() :
    connections(),
    mousegrab_box(),
    <...>
{
    mousegrab_box = new CheckBox(<...>);
    connections.push_back(                              @bind_11
        config_manager.on_mouse_grab_change.connect(
            std::bind(&CheckBox::set_state, mousegrab_box, <...>, false); @bind_false
        )
    );                                                  @bind_12
    connections.push_back(                              @bind_21
        mousegrab_box->on_change.connect(
            std::bind(&ConfigManager::set_mouse_grab, &config_manager, <...>);
        )
    );                                                  @bind_22
    <...>

}

OptionMenu::~OptionMenu() {     @destr_1
    for (Connections::iterator i=connections.begin(); i!=connections.end(); ++i) {
        (*i).disconnect();
    }
}                               @destr_2


\end{lstlisting}
\centering\small{\ax Implementation in C++}
\end{minipage}
%
\begin{minipage}[t]{0.40\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=3em]
spawn do
    var _SDL_KeyboardEvent&& e;
    every e in SDL_KEYDOWN do
        var _u8&& keystate = _SDL_GetKeyState(null);
        <...>
        if e:keysym.sym == {SDLK_g} then
            if ((keystate[{SDLK_LCTRL}] as bool) or (keystate[{SDLK_RCTRL}] as bool)) then
                emit config_manager.go_mouse_grab(    @ctrl_g_ceu
                        not ({config_manager.get_mouse_grab()} as bool));
            end
        end
        <...>
    end
end

///

data ConfigManager with
    event bool go_mouse_grab;
end
var ConfigManager config_manager = val ConfigManager(_);

spawn do
    var bool v;
    every v in config_manager.go_mouse_grab do
        <...>   // the actual "grab" effect
    end
end

///

data ICheckBox with
    var   bool is_on;
    event bool go_click;
end

code/await CheckBox (<...>) -> (var ICheckBox checkbox) -> FOREVER do
    checkbox = val ICheckBox(<...>);
    <...>
    par do
        every c.component.on_click do                   @every_1
            emit checkbox.go_click(not checkbox.is_on); @dir_class_app
        end                                             @every_2
    with
        loop do                                         @loop_1
            <...>   // switches the check box state
            checkbox.is_on = await checkbox.go_click;   @dir_app_class
        end                                             @loop_2
    end
end

///

code/await OptionMenu <...> do
    <...>
    var& CheckBox b2 = <...>;
    spawn do
        par do
            var bool v;
            every v in outer.config_manager.go_mouse_grab do    @loop_11
                emit b2.checkbox.go_click(v);
            end                                                 @loop_12
        with
            var bool v;
            every v in b2.checkbox.go_click do                  @loop_21
                emit outer.config_manager.go_mouse_grab(v);
            end                                                 @loop_22
        end
    end
    <...>
end

\end{lstlisting}
\centering\small{\bx Implementation in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Shared-memory concurrency in \CEU:
example \ax is safe because the trails access \code{x} atomically in different 
reactions;
example \bx is unsafe because both trails access \code{y} in the same reaction.
\label{lst.shared}
}
\end{figure*}

In C++, the class `GlobalEvent` detects *Ctrl-G*
presses and invokes the callback `config\_manager.set\_mouse\_grab`:
%
The class `ConfigManager` uses a `boost::signal`
[[![X]][boost\_signal]] to notify the application when the new configuration is
applied:
%
The `if` enclosing the signal emission @NN(if\_1,-,if\_2) breaks the dependency 
cycle of Figure~\ref{fig.events} and prevents an infinite execution loop.
%
The class `CheckBox` also uses a `boost::signal` to 
notify the application on changes:
%
Again, the `if` enclosing the signal emission @NN(if\_cb\_1,-,if\_cb\_2) breaks the 
dependency cycle of Figure~\ref{fig.events} to avoid infinite execution.
%
The class `OptionMenu` creates the dependency loop by
connecting the two signals:
%
The constructor binds
the signal `config\_manager.on\_mouse\_grab\_change` to the callback method
           `mousegrab\_box->set\_state`
           @NN(bind\_11,-,bind\_12),
and also
the signal `mousegrab\_box->on\_change` to the callback method
           `config\_manager.set\_mouse\_grab`
           @NN(bind\_21,-,bind\_22).
This way, every time the `ConfigManager` signals `on\_mouse\_grab\_change`
(`ConfigManager`, ln. @N(signal) [up](\#cpp\_config-manager)), `set\_state` is
implicitly called.
The same happens between the signal `on\_change` in the `CheckBox` and the 
method `set\_mouse\_grab` in the `ConfigManager`
(`ConfigManager`, ln. @N(set\_mouse\_grab) [up](\#cpp\_config-manager)).
%
Note that the signal binding to call `CheckBox::set\_state` @NN(bind\_false) 
receives a fixed value `false` as the last argument to prevent infinite
execution (`CheckBox`, ln. @N(last\_argument) [up](\#cpp\_check-box)).
%
The destructor @NN(destr\_1,-,destr\_2) breaks the connections explicitly when
the *Option* screen terminates.

In \CEU, a *Ctrl-G* key press broadcasts the internal event
`config\_manager.go\_mouse\_grab` to the application [[![X]][ceu\_global\_event]]:
%
The configuration manager [[![X]][ceu\_config\_manager]] just needs to react to
`go\_mouse\_grab` continuously to perform the *grab* effect:
%
The `CheckBox` [[![X]][ceu\_check\_box]] exposes the event `go\_click` for 
notifications in both directions, i.e., from the abstraction to the application
and *vice versa*:
%
The abstraction reacts to external clicks continuously @NN(every\_1,-,every\_2)
to broadcast the event `go\_click` @NN(dir\_class\_app).
It also reacts continuously to `go\_click` in another line of execution
@NN(loop\_1,-,loop\_2), which awakes from notifications from the first line of
execution or from the application.
%
The `OptionMenu` [[![X]][ceu\_option\_menu]] connects the two events as 
follows:
%
The two loops in parallel handle the connections in opposite directions:
from the configuration manager to the check box @NN(loop\_11,-,loop\_12);
and
from the check box to the configuration manager @NN(loop\_21,-,loop\_22).
%
When the *Option* screen terminates, the connections break automatically since
the body is automatically aborted.
%
Note that the implementation in \CEU does not check event emits to break the
dependency cycle and prevent infinite execution.
Due to the [stack-based execution for internal events][ceu\_stack] in \CEU,
programs with mutually-dependent events do not create infinite execution loops.

\section{Related Work}

\section{Conclusion}

We promote the \emph{structured synchronous reactive} programming model of
\CEU for the development of games.
We present in-depth use cases categorized in 5 control-flow patterns applied to
\emph{Pingus} (an open-source \emph{Lemmings} clone) that likely apply to other
games.

We show how the standard way to program games with objects and callbacks in C++
hinders structured programming techniques, such as support for sequential
execution, long-lasting loops, and persisting local variables.
In this sense, callbacks actually disrupt structured programming, becoming
["our generation’s goto"][goto] according to Miguel de Icaza.

Overall, we believe that most difficulties in implementing control behavior in 
game logic is not inherent to this domain, but a result of accidental
complexity due to the lack of structured abstractions and an appropriate
concurrency model to handle event-based applications.

[goto]: http://tirania.org/blog/archive/2013/Aug-15.html

\section{Acknowledgments}

[Leonardo Kaplan](https://github.com/leokaplan/) and
[Alexander Tkachov](https://github.com/Tkachov/)
for early explorations and prototypes.

\bibliographystyle{abbrv}
\bibliography{my,other}
\end{document}
